'From VisualWorks(R) Release 2.0 of 4 August 1994 on 5 October 1995 at 7:49:42 am'!



Object subclass: #POSTerminal
	instanceVariableNames: 'itemBarcode itemQuantity item taxReference storeReference storeAccessReference outputMediaReference itemExtension saleSubtotal saleTaxableSubtotal saleTotal saleTax POSTotal POSTaxTotal POSid '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
POSTerminal comment:
'The POS class handles the interactions between the media devices (keypad, barcode scanner, and sales tape). The state of a sales transaction is maintained by the POS object. Sales reports for the POS object or the entire store are generated by the POS object.

The Smalltalk implementation of the POS object hard codes the POS id.'!


!POSTerminal methodsFor: 'POSTerminal'!

endOfSale
	"Called when the 'T' command is entered at the keypad. 
	Complete sale by calculating tax on taxable 
	items, complete the printing of the sales slip, 
	report the sale to the store, and prepare for the next command. 
	This method is the implementation of the IDL operation ::POS::POSTerminal::end_of_sale."

	| msg |
	self checkForLogin.
	msg := String new writeStream.
	msg nextPutAll: 'Taxable subtotal: '; nextPutAll: (self format: saleTaxableSubtotal); nextPut: Character space.
	outputMediaReference outputText: msg contents.
	saleTax := taxReference calculateTax: saleTaxableSubtotal.
	saleTotal := saleSubtotal + saleTax.
	msg reset.
	msg nextPutAll: 'Total: '; nextPutAll: (self format: saleTotal).
	outputMediaReference outputText: msg contents.
	POSTotal := POSTotal + saleTotal.
	POSTaxTotal := POSTaxTotal + saleTax.
	storeReference
		updateStoreTotals: POSid
		price: saleTotal
		taxes: saleTax.
	itemBarcode := nil.
	saleSubtotal := saleTaxableSubtotal := 0.0.
	itemQuantity := 1!

itemQuantity: quantity 
	"Set the quantity to be applied to an individual barcode scan. Successive calls simply overwrite the 
	previous quantity. The quantity is reset to one after barcode processing is complete so that the next
	barcode will be processed with quantity one. 
	This method is the implementation of the IDL operation ::POS::POSTerminal::item_quantity."

	self checkForLogin.
	itemQuantity := quantity!

login
	"Called from the keypad indicating that a new cashier is logging in. 
	Notify the store via the login message. Save the returned storeAccess 
	object reference for later use. This method is the implementation of 
	the IDL operation ::POS::POSTerminal::login."

	storeAccessReference isNil ifFalse: [self error: 'Cannot login in twice!!'].
	itemQuantity := 1.
	saleSubtotal := saleTaxableSubtotal := saleTotal := saleTax := POSTotal := POSTaxTotal := 0.0.
	storeAccessReference := storeReference login: POSid!

printPOSSalesSummary
	"Print the sales total (sales and taxes) since the last login. This message is sent by the keypad when 
	the 'P' command is entered at the keypad. Ignore this message (do nothing) if itemBarcode or 
	saleSubTotal is non zero since that indicates that the POS terminal is in the middle of a sale. 
	This method is the implementation of the IDL operation 
	::POS::POSTerminal::print_POS_sales_summary."

	| msg |
	self checkForLogin.
	itemBarcode isNil ifFalse: [^self].
	saleSubtotal isZero ifFalse: [^self].
	msg := String new writeStream.
	msg nextPutAll: 'Totals for POS terminal '; nextPutAll: POSid printString.
	outputMediaReference outputText: msg contents.
	msg reset.
	msg tab; nextPutAll: 'Total Sales: '; nextPutAll: (self format: POSTotal).
	outputMediaReference outputText: msg contents.
	msg reset.
	msg tab; nextPutAll: 'Total Taxes: '; nextPutAll: (self format: POSTaxTotal).
	outputMediaReference outputText: msg contents!

printStoreSalesSummary
	"Print the totals (sales and taxes) for the store since the store 
	computer was last initialized. Also print 
	the totals (sales and taxes) for each POS that is logged in. This 
	message is sent by the keypad when 
	the 'S' command is entered. Ignore this message (do nothing) if 
	itemBarcode or saleSubTotal is non 
	zero since that would indicate that the POS terminal is in the 
	middle of a sale. 
	This method is the implementation of the IDL operation 
	::POS::POSTerminal::print_store_sales_summary."

	| msg aList totals |
	self checkForLogin.
	itemBarcode isNil ifFalse: [^self].
	saleSubtotal isZero ifFalse: [^self].
	msg := String new writeStream.
	msg nextPutAll: 'Totals for store '; nextPutAll: storeReference StoreId printString.
	outputMediaReference outputText: msg contents.
	msg reset.
	totals := storeReference Totals.
	msg tab; nextPutAll: 'Total Store Sales: $'; nextPutAll: (self format: (totals at: #StoreTotal)).
	outputMediaReference outputText: msg contents.
	msg reset.
	msg tab; nextPutAll: 'Total Store Taxes: $'; nextPutAll: (self format: (totals at: #StoreTaxTotal)).
	outputMediaReference outputText: msg contents.
	msg reset.
	storeReference getPOSTotals: (aList := nil asCORBAParameter).
	aList value
		do: 
			[:t | 
			msg tab; nextPutAll: 'Totals for POS terminal '; nextPutAll: t Id printString.
			outputMediaReference outputText: msg contents.
			msg reset.
			msg tab; tab; nextPutAll: 'Total Sales: '; nextPutAll: (self format: t TotalSales).
			outputMediaReference outputText: msg contents.
			msg reset.
			msg tab; tab; nextPutAll: 'Total Taxes: '; nextPutAll: (self format: t TotalTaxes).
			outputMediaReference outputText: msg contents]!

sendBarcode: barcodeString 
	"Called from the barcode scanner when an item has been 'scanned'. Messages are sent by the 
	receiver to the store and depot to inform of inventory reductions and to get retail and taxable prices. 
	This method is the implementation of the IDL operation ::POS::POSTerminal::send_barcode."

	| price tax msg itemInfo|
	self checkForLogin.
	price := nil asCORBAParameter.
	tax := nil asCORBAParameter.
	itemInfo := nil asCORBAParameter.
	itemBarcode := barcodeString.
	(CORBAConstants at: '::AStore::BarcodeNotFound')
		corbaHandle: 
			[:ev | 
			itemBarcode := nil.
			itemQuantity := 1.
			^nil]
		do: 
			[storeAccessReference
				findPrice: itemBarcode
				quantity: itemQuantity
				itemPrice: price
				itemTaxPrice: tax
				iInfo: itemInfo.
			saleSubtotal := saleSubtotal + (price value * itemQuantity).
			saleTaxableSubtotal := saleTaxableSubtotal + (tax value * itemQuantity).
			msg := String new writeStream.
			msg nextPutAll: itemBarcode.
			tax value isZero ifFalse: [msg nextPutAll: '*  ']
				ifTrue: [msg nextPutAll: '   '].
			msg nextPutAll: itemInfo value Name; space; nextPutAll: itemQuantity printString; space; nextPutAll: (self format: price value); space; nextPutAll: (self format: price value * itemQuantity).
			outputMediaReference outputText: msg contents.
			itemQuantity := 1]!

sendBarcodeAndQuantity: barCodeString quantity: aCount 
	"Convenience function for handling both barcode and quantity in one call. 
	This method is the implementation of the IDL operation 
	::POS::POSTerminal::send_barcode_and_quantity."

	self itemQuantity: aCount.
	self sendBarcode: barCodeString! !

!POSTerminal methodsFor: 'repository'!

CORBAName
	"Map this Smalltalk class to its IDL interface."

	^#'::POS::POSTerminal'! !

!POSTerminal methodsFor: 'initialization'!

initialize: aStoreId posId: anId 
	"Initialize a POSTerminal instance. 
	Get references to the tax, store, and outputMedia objects."

	| pns |
	pns := ORBObject pseudoNameService.
	taxReference := pns resolveName: 'Tax_' , aStoreId asString.
	storeReference := pns resolveName: 'Store_' , aStoreId asString.
	outputMediaReference := pns resolveName: 'OutputMedia_' , anId asString.
	itemBarcode := nil.
	POSid := anId.
	POSTotal := POSTaxTotal := 0.0.
	saleSubtotal := saleTaxableSubtotal := 0.0! !

!POSTerminal methodsFor: 'private'!

checkForLogin
	"Check to see if logged in BEFORE allowing operation. If there is a 
	StoreAccess reference then the POS terminal is logged in."

	storeAccessReference isNil ifTrue: [self error: 'Need to login in first!!']!

format: amount 
	"Format amount as a dollar amount"

	^PrintConverter print: amount formattedBy: '$######.##'! !


Object subclass: #Store
	instanceVariableNames: 'storeTotal storeTaxTotal POSTerminals storeMarkup storeId '
	classVariableNames: 'SA '
	poolDictionaries: ''
	category: 'OMG Primer Example'!
Store comment:
'The Store class accepts logins from POS terminals and keeps track of the running sales and tax totals. A store wide sales and tax total is also kept. The Store responds to requests to login more POS terminals, report on all POS terminals logged in, and update Store and POS terminal sales and tax totals.'!


!Store methodsFor: 'Store'!

getPOSTotals: list
	"Return the collection of registered (logged in) POS terminals for this store. 
	This method is the implementation of the IDL ::AStore::Store::get_POS_totals operation."

	list value: POSTerminals copy!

login: aPOSId 
	"Accept a login from a POSTerminal. Check to see if the terminal is 
	already logged in. If so do 
	nothing. Otherwise create a new POSInfo instance and initialize it 
	with its store access object, store id 
	and markup, and add it to the collection of logged in POS terminals 
	for this store. Return the store 
	access object reference. 
	This method implements the IDL ::AStore::Store::login operation."

	| pos |
	pos := POSTerminals detect: [:t | t Id = aPOSId]
				ifNone: [nil].
	pos isNil
		ifTrue: 
			[pos := POSInfo new: aPOSId.
			SA := StoreAccess new initialize: storeId markup: storeMarkup.
			pos StoreAccessReference: SA.
			POSTerminals add: pos]
		ifFalse: [pos reset].
	^pos StoreAccessReference!

StoreId
	"Return the value of the store id attribute."

	^storeId!

Totals
	"Return the value of the store totals attribute."

	^Dictionary with: #StoreTotal -> storeTotal with: #StoreTaxTotal -> storeTaxTotal!

updateStoreTotals: posId price: sales taxes: taxes 
	"Increment the sales and tax totals for a given POS terminal and for the store. 
	This method implements the ::AStore::Store::update_store_totals IDL operation."

	| pos |
	pos := POSTerminals detect: [:t | t Id = posId]
				ifNone: [self error: 'POS not found in list.'].
	pos addToSales: sales.
	pos addToTaxes: taxes.
	storeTotal := storeTotal + sales.
	storeTaxTotal := storeTaxTotal + taxes! !

!Store methodsFor: 'initialization'!

initialize: theStoreId markup: theMarkup 
	"Initialize a new Store object. 
	Set the id and the markup. 
	Reset the running totals to zero. 
	Setup for logins."

	storeId := theStoreId.
	storeMarkup := theMarkup.
	storeTotal := 0.0.
	storeTaxTotal := 0.0.
	POSTerminals := OrderedCollection new! !

!Store methodsFor: 'repository'!

CORBAName
	"Map this Smalltalk class to its IDL interface."

	^#'::AStore::Store'! !


!DSTRepository methodsFor: 'OMG Primer Example'!

// AStore
module AStore  {

	enum ItemTypes {food, clothes, other};

	typedef  long AStoreId;

	#pragma class ItemInfo ItemInfo
	struct ItemInfo {
		POS::Barcode Item;
		ItemTypes Itemtype;
		float Itemcost;
		string Name;
		long Quantity;
	};

	exception BarcodeNotFound {POS::Barcode item; };
	interface StoreAccess;

	#pragma class POSInfo POSInfo
	struct POSInfo {
		POS::POSId Id;
		StoreAccess StoreAccessReference;
		float TotalSales;
		float TotalTaxes;
	};

	typedef  sequence<POSInfo> POSList;

	interface Tax {

		float CalculateTax (in float TaxableAmount);
		float FindTaxablePrice (in float ItemPrice, in ItemTypes ItemType);
	};

	interface Store {

		struct  StoreTotals {float StoreTotal; float StoreTaxTotal; };

		readonly attribute AStoreId StoreId;
		readonly attribute StoreTotals Totals;
		StoreAccess Login (in POS::POSId Id);
		void GetPOSTotals (out POSList POSData);
		void UpdateStoreTotals (in POS::POSId Id, in float Price, in float Taxes);
	};

	interface StoreAccess {

		void FindPrice (
						in POS::Barcode Item,
						in long Quantity,
						out float ItemPrice,
						out float ItemTaxPrice,
						out ItemInfo IInfo)
					raises (BarcodeNotFound);
	};
};!

// CentralOffice
module CentralOffice  {

	interface Depot {

		#pragma  selector FindItemInfo findItemInfo:barCode:quantity:itemInfo:
		void FindItemInfo (
						in AStore::AStoreId StoreId,
						in POS::Barcode Item,
						in long Quantity,
						out AStore::ItemInfo IInfo)
					raises (AStore::BarcodeNotFound);
	};
};!

// POS
module POS  {

	typedef  long POSId;

	typedef  string Barcode;

	interface InputMedia {

		typedef  string OperatorCmd;

		void BarcodeInput (in Barcode Item);
		void KeypadInput (in OperatorCmd Cmd);
	};

	interface OutputMedia {

		boolean OutputText (in string StringToPrint);
	};

	interface POSTerminal {

		void Login ();
		void PrintPOSSalesSummary ();
		void PrintStoreSalesSummary ();
		void SendBarcode (in Barcode Item);
		void ItemQuantity (in long Quantity);
		void EndOfSale ();
	};
};!

// PseudoNameService
interface PseudoNameService {

	void BindName (in string ObjectName, in Object ObjectRef);
	Object ResolveName (in string ObjectName);
};! !


!ORBObject class methodsFor: 'ORB-naming'!

pseudoNameService
	"Return the pseudo naming service"

	^ORBObject referenceFromFile: 'pns.dat'! !


Object subclass: #Depot
	instanceVariableNames: 'storedb '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
Depot comment:
'The depot maintains the database for the application. When the depot is initialized an identityDictionary is constructed that has as its key a storeid and as its value a store database. The store database is a dictionary with a barcode key and an instance of a StoreDBItem as the value.

The dictionary is constructed from ascii files which are located in the ''db'' directory. The name of the file is the store id. The files consist of lines terminated by carriage returns. Each line has the following format:
		barcode		description		quantity		itemcost	taxtype

A depot responds to the message (query) findItemInfo.

Depot uses the following classes:
	ParseStoreDB	--	Called to parse the ascii database files at initialization time
	ItemInfo			--	The result type of the findItemInfo message
	ItemInfo			--	An instance of this class is created for each line in the database for
						a store'!


!Depot methodsFor: 'Depot'!

findItemInfo: aStoreId barCode: aBarcode quantity: aCount itemInfo: info 
	"Lookup the barcode in the store database. This example has a single 
	database for all stores and so the store id is not used to select the 
	database. If the barcode is not found then the BarcodeNotFound 
	exception is raised. If the item is found then the inventory count is 
	decremented by the quantity requested. No check is done for 
	allocating more items than are in the inventory. 
	Return item as an out parameter. 
	This method is the implementation of the IDL operation 
	::CentralOffice::Depot::FindItemInfo."

	| item |
	item := storedb at: aBarcode ifAbsent: [^(CORBAConstants at: #'::AStore::BarcodeNotFound')
					corbaRaiseWith: (Dictionary with: (Association key: #item value: aBarcode))].
	item Quantity: item Quantity - aCount.
	info value: item! !

!Depot methodsFor: 'private'!

readStoreDatabase: fileName 
	"Read the store database from the specified file. 
	Check for the existence of the filename. 
	If the file exists call ParseStoreDB to parse the contents of the file. 
	Return the result of the parse."

	| fileStream db |
	fileName isReadable
		ifTrue: [
			[fileStream := fileName readStream.
			db := ParseStoreDB new parse: fileStream]
				valueNowOrOnUnwindDo: [fileStream close]]
		ifFalse: [db := nil].
	^db! !

!Depot methodsFor: 'initialization'!

initialize
	"Call readStoreDatabase on 'depot.dat' and parse the contents of the 
	store database ascii representation. Store the result in storedb."

	storedb := self readStoreDatabase: 'depot.dat' asFilename! !

!Depot methodsFor: 'repository'!

CORBAName
	"Map this Smalltalk class to its IDL interface."

	^#'::CentralOffice::Depot'! !


Object subclass: #OMGPrimerExample
	instanceVariableNames: ''
	classVariableNames: 'DEPOT OM PNS POS STORE TAX '
	poolDictionaries: ''
	category: 'OMG Primer Example'!
OMGPrimerExample comment:
'This class enables the running of the OMG primer example. 
'!

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OMGPrimerExample class
	instanceVariableNames: ''!


!OMGPrimerExample class methodsFor: 'startup'!

createDepot
	"This method will create a depot object and register its reference 
	with the pseudo name service."

	| pns |
	DEPOT := Depot new initialize.
	pns := ORBObject pseudoNameService.
	pns bindName: 'Depot' objectRef: DEPOT!

createOutputMedia: posId 
	"This method will create an OutputMedia object (sales tape printer) 
	associated with the POS terminal identified by posId. The reference 
	is bound into the pseudo name service."

	|  pns |
	OM := OutputMedia new initialize: posId.
	pns := ORBObject pseudoNameService.
	pns bindName: 'OutputMedia_' , posId asString objectRef: OM!

createPNS
	"This method creates a pseudo name service (pns) object which will 
	act as the server for the pns for the demo. The reference to the pns 
	object is written to the file 'pns.dat' as a stringified object reference. 
	Other images can unstringify the reference thus connecting to the 
	pns service."

	PNS := PseudoNameService new.
	ORBObject referenceToFile: 'pns.dat' object: PNS!

createPOSTerminal: aPOSId store: aStoreId 
	"This method will create a POS terminal with the given id and 
	associated with the given store. It also creates an inputmedia object 
	(barcode scanner and keypad) which is associated with the POS 
	terminal."

	| im|
	POS := POSTerminal new initialize: aStoreId posId: aPOSId.
	im := InputMedia new initialize: POS.
	im builder window label: 'POS Terminal #', aPOSId asString.!

createStore: storeId markup: percentage 
	"This method is used to create a Store and Tax object. The store and 
	tax references are then added to the pseudo name service under 
	the name Store_n and Tax_n respectively, where n is the store id 
	number."

	| pns |
	pns := ORBObject pseudoNameService.
	STORE := Store new initialize: storeId markup: percentage.
	pns bindName: 'Store_' , storeId asString objectRef: STORE.
	TAX := Tax new.
	pns bindName: 'Tax_' , storeId asString objectRef: TAX!

localRPCDemo
	"This method starts up the OMG primer example in a single HP DST 
	image. The store id is 42 and the POS terminal is terminal 10."

	self createPNS.
	self createDepot.
	self createOutputMedia: 10.
	self createStore: 42 markup: 0.1.
	self createPOSTerminal: 10 store: 42! !


Scanner subclass: #ParseStoreDB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
ParseStoreDB comment:
'This class parses ascii store database files and creates StoreDBItem instances for each line in the file.'!


!ParseStoreDB methodsFor: 'scanning'!

scanLine: aString 
	"Tokenize a line of the ascii store database file. 
	Create an instance of a ItemInfo and initialize its instance variables 
	with the scanned tokens. 
	Return an association consisting of the barcode and the ItemInfo 
	instance."

	| item |
	item := ItemInfo new.
	self scan: aString readStream.
	item Item: token asString.
	self scanToken.
	item Name: token.
	self scanToken.
	item Quantity: token.
	self scanToken.
	item Itemcost: token.
	self scanToken.
	item Itemtype: (self symbolToEnumerator: token asLowercase asSymbol).
	^item Item -> item!

symbolToEnumerator: aSymbol 
	"Convert the argument to the equivalent enumerator associated with 
	the ::AStore::ItemTypes enumeration."

	| syms |
	syms := CORBAConstants at: #'::AStore::ItemTypes'.
	(syms includes: aSymbol)
		ifTrue: [^CORBAConstants at: #'::AStore::ItemTypes::' , aSymbol]! !

!ParseStoreDB methodsFor: 'parsing'!

parse: aStream 
	"Parse the parameter stream a line at a time. A line is terminated by a carriage return. Collect the 
	result of the parse into a dictionary."

	| db |
	db := Dictionary new.
	[aStream atEnd]
		whileFalse: [db add: (self scanLine: (aStream upTo: Character cr))].
	^db! !


Object subclass: #OutputMedia
	instanceVariableNames: 'transcript view '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
OutputMedia comment:
'OutputMedia simulates a sales tape printer showing the current status of a transaction.
It is simulated via a TextCollector and an associated TextCollectorView.'!


!OutputMedia methodsFor: 'OutputMedia'!

outputText: aString 
	"This method is the implementation of the IDL operation 
	::POS::OutputMedia::OutputText. 
	The parameter is simply written on the text collector."

	transcript show: aString; cr.
	^true! !

!OutputMedia methodsFor: 'accessing'!

transcript
	"Return the current TextCollector."

	^transcript!

transcript: newTranscript 
	"Set the TextCollector."

	transcript := newTranscript!

view
	"Return the TextCollector's view."

	^view!

view: newView 
	"Set the TextCollector's view."

	view := newView! !

!OutputMedia methodsFor: 'initialize'!

initialize: aPOSId 
	"Initialize the output media object. 
	An outputmedia object is implemented as a TextCollector with an 
	associated TextCollectorView. Set this up."

	self transcript: TextCollector new.
	self view: (TextCollectorView createOn: self transcript label: 'Sales Tape Printer for POS Terminal #', aPOSId asString).
	self view minimumSize: 500 @ 150.
	self view maximumSize: 500 @ 150.
	self view open.
	^self! !

!OutputMedia methodsFor: 'repository'!

CORBAName
	"Map this Smalltalk class to its IDL interface."

	^#'::POS::OutputMedia'! !


Object subclass: #StoreAccess
	instanceVariableNames: 'storeId storeMarkup tax depot '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
StoreAccess comment:
'StoreAccess is the intermediary between the POS object and the central Depot. It allows the POS to access the item database maintained in the Depot object. One StoreAccess object is created for each POS that logs into the Store.'!


!StoreAccess methodsFor: 'StoreAccess'!

findPrice: aBarcode quantity: aCount itemPrice: aPrice itemTaxPrice: aTaxPrice iInfo: item 
	"Tell the depot about inventory reduction and ask for item cost and tax type. 
	Calculate the item price and item tax price from this information. Return the calculated item price and taxes. 
	This method implements the IDL operation ::AStore::StoreAccess::find_price."

	| itemInfo cost |
	(CORBAConstants at: '::AStore::BarcodeNotFound')
		corbaHandle: [:ev | ^(CORBAConstants at: #'::AStore::BarcodeNotFound')
				corbaRaiseWith: (Dictionary with: (Association key: #item value: aBarcode))]
		do: 
			[depot
				findItemInfo: storeId
				barCode: aBarcode
				quantity: aCount
				itemInfo: (itemInfo := nil asCORBAParameter).
			cost := itemInfo value Itemcost.
			cost := cost + (cost * storeMarkup).
			aPrice value: cost.
			aTaxPrice value: (tax findTaxablePrice: cost itemType: itemInfo value Itemtype).
			item value: itemInfo value]! !

!StoreAccess methodsFor: 'accessing'!

StoreId
	"Return the store id associated with this access object."

	^storeId!

StoreId: anId 
	"Set the store id associated with this access object."

	storeId := anId!

storeMarkup
	"Return the store markup associated with this access object."

	^storeMarkup!

storeMarkup: aMarkup 
	"Set the store markup associated with this access object."

	storeMarkup := aMarkup! !

!StoreAccess methodsFor: 'initialization'!

initialize: theStoreId markup: theMarkup 
	"Initialize the state of the StoreAccess instance. Set the storeId and 
	storeMarkup to the input arguments. Retrieve references to the tax 
	and depot objects from the pseudo name service."

	| pns |
	storeId := theStoreId.
	storeMarkup := theMarkup.
	pns := ORBObject pseudoNameService.
	depot := pns resolveName: 'Depot'.
	tax := pns resolveName: 'Tax_' , storeId asString! !

!StoreAccess methodsFor: 'repository'!

CORBAName
	"Map this Smalltalk class to its IDL interface."

	^#'::AStore::StoreAccess'! !


ApplicationModel subclass: #InputMedia
	instanceVariableNames: 'barcode POSReference quantity '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
InputMedia comment:
'InputMedia simulates a keypad and barcode scanner for demo purposes. 

The barcode scanner is simulated via an input field and a push button. The barcode is typed into the input field. When the scan push button is pressed the barcode is sent to the POSTerminal object.

The keypad is simulated via five push buttons and an input field. There is a push button for each of the following operations:
	L --  a login as a new cashier request.
	P -- a print all sales since last login request.
	S -- a sum of all store sales request. 
	Q -- a item quantity request. 
	T -- an end of sales request. 
The input field is associated with the Q key. The number of items (quantity) is typed into the input field before the Q button is pressed.'!


!InputMedia methodsFor: 'aspects'!

barcode
	"barcode is the aspect associated with the scan button. 
	Its default value is the empty string."

	^barcode isNil
		ifTrue: [barcode := String new asValue]
		ifFalse: [barcode]!

quantity
	"quantity is the aspect associated with the input field for the Q key. 
	Its default value is one."

	^quantity isNil
		ifTrue: [quantity := 1 asValue]
		ifFalse: [quantity]! !

!InputMedia methodsFor: 'actions'!

barcodeInput
	"The barcode scanner is simulated by an input field. The input field's 
	aspect is barcode. When the scan button is pushed this routine is 
	called. The value of the aspect is retrieved and a sendBarcode 
	message is sent to the POSTerminal object associated with this 
	scanner."

	POSReference sendBarcode: self barcode value!

cashierLogin
	"An L key was pressed on the keypad. 
	Send a login message to the POSTerminal."

	POSReference login!

endOfSale
	"A T key was pressed on the keypad. 
	Send a endSale message to the POSTerminal."

	POSReference endOfSale!

itemQuantity
	"A Q key was pressed on the keypad. 
	Get the input field value associated with the Q push button (aspect quantity). 
	Send an itemQuantity: message to the POSTerminal."

	POSReference itemQuantity: self quantity value!

printPOSSalesSummary
	"A P key was pressed on the keypad. 
	Send a printPOSSalesSummary message to the POSTerminal."

	POSReference printPOSSalesSummary!

printStoreSalesSummary
	"A S key was pressed on the keypad. 
	Send a printStoreSalesSummary message to the POSTerminal."

	POSReference printStoreSalesSummary! !

!InputMedia methodsFor: 'initialization'!

initialize: aPOSTerminal 
	"Save the POS terminal reference away. 
	Display the user interface."

	POSReference := aPOSTerminal.
	self open! !
"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InputMedia class
	instanceVariableNames: ''!


!InputMedia class methodsFor: 'interface specs'!

windowSpec
	"UIPainter new openOnClass: self andSelector: #windowSpec"

	<resource: #canvas>
	^#(#FullSpec 
		#window: 
		#(#WindowSpec 
			#label: 'OMG Primer Example' 
			#min: #(#Point 272 215 ) 
			#max: #(#Point 272 215 ) 
			#bounds: #(#Rectangle 355 343 627 558 ) 
			#menu: #menuBar ) 
		#component: 
		#(#SpecCollection 
			#collection: #(
				#(#LabelSpec 
					#layout: #(#Point 31 18 ) 
					#label: 'Barcode Scanner' ) 
				#(#LabelSpec 
					#layout: #(#Point 58 83 ) 
					#label: 'Keypad' ) 
				#(#InputFieldSpec 
					#layout: #(#Rectangle 15 46 149 70 ) 
					#model: #barcode 
					#alignment: #right 
					#type: #string ) 
				#(#ActionButtonSpec 
					#layout: #(#Rectangle 179 42 234 72 ) 
					#model: #barcodeInput 
					#label: 'Scan' 
					#defaultable: true ) 
				#(#ActionButtonSpec 
					#layout: #(#Rectangle 20 114 72 139 ) 
					#model: #cashierLogin 
					#label: 'L' 
					#defaultable: true ) 
				#(#ActionButtonSpec 
					#layout: #(#Rectangle 91 115 143 140 ) 
					#model: #printPOSSalesSummary 
					#label: 'P' 
					#defaultable: true ) 
				#(#ActionButtonSpec 
					#layout: #(#Rectangle 20 147 72 172 ) 
					#model: #printStoreSalesSummary 
					#label: 'S' 
					#defaultable: true ) 
				#(#ActionButtonSpec 
					#layout: #(#Rectangle 92 148 144 173 ) 
					#model: #endOfSale 
					#label: 'T' 
					#defaultable: true ) 
				#(#ActionButtonSpec 
					#layout: #(#Rectangle 92 182 144 207 ) 
					#model: #itemQuantity 
					#label: 'Q' 
					#defaultable: true ) 
				#(#InputFieldSpec 
					#layout: #(#Rectangle 21 181 69 206 ) 
					#model: #quantity 
					#alignment: #right 
					#type: #number ) ) ) )! !


Object subclass: #POSInfo
	instanceVariableNames: 'id totalSales totalTaxes storeAccessReference '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
POSInfo comment:
'This class is used to return the result from the Store>>getPOSTotals method. The Store>>getPOSTotals method actually returns an ordered collection of POSInfo objects.
This class gets mapped to the IDL ::AStore::POSInfo structure for marshalling and unmarshalling purposes. 
See the CORBAType method on this class.'!


!POSInfo methodsFor: 'accessing'!

Id
	"Return the POSid."

	^id!

Id: newId 
	"Set the POSid."

	id := newId!

StoreAccessReference
	"Return the store access object reference."

	^storeAccessReference!

StoreAccessReference: anAccessObject 
	"Set the store access object reference."

	storeAccessReference := anAccessObject!

TotalSales
	"Return the total sales for the receiver POS."

	^totalSales!

TotalSales: sales 
	"Set the total sales for the receiver POS."

	totalSales := sales!

TotalTaxes
	"Return the total taxes for the receiver POS."

	^totalTaxes!

TotalTaxes: taxes 
	"Set the total taxes for the receiver POS."

	totalTaxes := taxes! !

!POSInfo methodsFor: 'initialization'!

initialize: aPOSId 
	"Set the POSId for this instance and clear the total sales and taxes."

	id := aPOSId.
	totalSales := 0.0.
	totalTaxes := 0.0! !

!POSInfo methodsFor: 'operations'!

addToSales: amount 
	"Increment the running sales total by the amount parameter."

	totalSales := totalSales + amount!

addToTaxes: amount 
	"Increment the running tax total by the amount parameter."

	totalTaxes := totalTaxes + amount!

reset
	"Clear the total sales and taxes."

	totalSales := 0.0.
	totalTaxes := 0.0! !

!POSInfo methodsFor: 'repository'!

CORBAType
	"Define the mapping from/to IDL/Smalltalk for the ::AStore::POSInfo structure. In other 
	words, POSInfo is the Smalltalk implementation of the IDL POSInfo structure."

	^ORBObject lookupMetaId: #'::AStore::POSInfo'! !
"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

POSInfo class
	instanceVariableNames: ''!


!POSInfo class methodsFor: 'initialize-release'!

new: aPOSId 
	"Create an instance of POSInfo, set its POSId, and return the instance."

	^self basicNew initialize: aPOSId! !


Object subclass: #ItemInfo
	instanceVariableNames: 'barCode name quantity itemCost taxType '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!
ItemInfo comment:
'The StoreDBItem represents an item in the store database. An instance of StoreDBItem is created for each line in the ascii file representing the store database (see ParseStoreDB).'!


!ItemInfo methodsFor: 'accessing'!

Item
	"Return the item's barcode."

	^barCode!

Item: aBarCode 
	"Set the item's barcode."

	barCode := aBarCode!

Itemcost
	"Return the item's cost."

	^itemCost!

Itemcost: aPrice 
	"Set the item's price."

	itemCost := aPrice!

Itemtype
	"Return the item's tax classification."

	^taxType!

Itemtype: aType 
	"Set the item's tax classification."

	taxType := aType!

Name
	"Return the item's name."

	^name!

Name: aName 
	"Set the item's name."

	name := aName!

Quantity
	"Return the item's current inventory count."

	^quantity!

Quantity: aCount 
	"Set the item's inventory count."

	quantity := aCount! !


Object subclass: #Tax
	instanceVariableNames: ''
	classVariableNames: 'RegionRate '
	poolDictionaries: ''
	category: 'OMG Primer Example'!
Tax comment:
'The Tax class performs tax services. For this example clothes and food are not taxable but everything else is taxed via a flat tax rate (5%).'!


!Tax methodsFor: 'Tax'!

calculateTax: amount 
	"Calculate the tax on the amount and return the result. 
	This method is the implementation of the IDL 
	::AStore::Tax::CalculateTax operation."

	^amount * RegionRate!

findTaxablePrice: itemPrice itemType: taxType 
	"Determine how much, if any, of the itemPrice is taxable. If the item 
	tax type is food or clothes then the item is not taxable. Otherwise 
	the item is taxable. This method is the implementation of the IDL 
	::AStore::Tax::FindTaxablePrice operation."

	taxType = (CORBAConstants at: #'::AStore::ItemTypes::other')
		ifTrue: [^itemPrice]
		ifFalse: [^0.0]! !

!Tax methodsFor: 'repository'!

CORBAName
	"Map this Smalltalk class to its IDL interface."

	^#'::AStore::Tax'! !
"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Tax class
	instanceVariableNames: ''!


!Tax class methodsFor: 'class initialization'!

initialize
	"Set the tax rate to 5%"

	RegionRate := 0.05! !


Object subclass: #PseudoNameService
	instanceVariableNames: 'bindings '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMG Primer Example'!


!PseudoNameService methodsFor: 'PseudoNameService'!

bindName: objectName objectRef: reference 
	"Bind the argument name to the argument reference so that the 
	object reference can be lookup by name at a later time. This mimics 
	the contextBind operation of the OMG Naming Service."

	bindings isNil ifTrue: [bindings := Dictionary new: 10].
	bindings at: objectName put: reference!

resolveName: objectName 
	"Lookup the object reference by name (the argument). If found then 
	return the object reference; otherwise return nil."

	^bindings at: objectName ifAbsent: [nil]! !

!PseudoNameService methodsFor: 'initialization'!

initialize
	"Initialize an instance of the PseudoNameService."

	bindings := Dictionary new: 10! !

!PseudoNameService methodsFor: 'repository'!

CORBAName
	"Map this Smalltalk class to its IDL interface."

	^#'::PseudoNameService'! !

Tax initialize!

