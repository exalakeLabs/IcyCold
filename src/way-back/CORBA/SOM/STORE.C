/*
 *   (C) COPYRIGHT International Business Machines Corp. 1995, 1996
 *   All Rights Reserved
 *   Licensed Materials - Property of IBM
 *   US Government Users Restricted Rights - Use, duplication or
 *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 *   DISCLAIMER OF WARRANTIES.
 *   The following [enclosed] code is sample code created by IBM
 *   Corporation. This sample code is not part of any standard or IBM
 *   product and is provided to you solely for the purpose of assisting
 *   you in the development of your applications.  The code is provided
 *   "AS IS". IBM MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT
 *   NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE, REGARDING THE FUNCTION OR PERFORMANCE OF
 *   THIS CODE.  IBM shall not be liable for any damages arising out of
 *   your use of the sample code, even if they have been advised of the
 *   possibility of such damages.
 *
 *   DISTRIBUTION.
 *   This sample code can be freely distributed, copied, altered, and
 *   incorporated into other software, provided that it bears the above
 *   Copyright notice and DISCLAIMER intact.
 */

/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.41
 */


#define SOM_Module_store_Source
#include <corba12.h>
#include <pos.h>
#include <store.ih>
#include <central.h>
#include <orb.h>
#include <stdio.h>
#include <pnamesvc.h>
#include <common.h>


#define STOREID  1
#define MARKUP   0.12

/*
 *-----------------------------------------------------------------------------
 * Structure definition for Store object state
 *-----------------------------------------------------------------------------
 */

typedef struct tagStoreState
{
  AStore_POSList            _poslist;
  AStore_POSInfo            _posarray[MAX_POSLIST_ENTRIES];
  AStore_Store_StoreTotals  _totals;
  CentralOffice_Depot       _depotReference;
  AStore_Tax                _taxReference;

  CORBA_float               _storeMarkup;
  AStore_AStoreId           _store_id;

} StoreState;

/*
 *-----------------------------------------------------------------------------
 * Structure definition for Tax object state
 *-----------------------------------------------------------------------------
 */

typedef struct tagTaxState
{
  CORBA_float      rate;

} TaxState;

/*
 *-----------------------------------------------------------------------------
 * Structure definition for StoreAccess  object state
 *-----------------------------------------------------------------------------
 */

typedef struct tagStoreAccessState
{
  CentralOffice_Depot  _depot_reference;
  AStore_Tax           _tax_reference;
  AStore_AStoreId      _store_id;
  CORBA_float          markup;

} StoreAccessState;

SOM_Scope float  SOMLINK AStore_TaxCalculateTax(AStore_Tax somSelf, 
                                                 Environment *ev, 
                                                float TaxableAmount)
{
    TaxState *ostate;
    AStore_TaxData *somThis = AStore_TaxGetData(somSelf);
    AStore_TaxMethodDebug("AStore_Tax","AStore_TaxCalculateTax");

    ostate = (TaxState *)somThis->ostate;

    printf("Tax_calculate_tax = %.2f\n",(TaxableAmount * ostate->rate));
    return (TaxableAmount * ostate->rate);
}

SOM_Scope float  SOMLINK AStore_TaxFindTaxablePrice(AStore_Tax somSelf, 
                                                     Environment *ev, 
                                                    float ItemPrice, 
                                                    AStore_ItemTypes ItemType)
{
    AStore_TaxData *somThis = AStore_TaxGetData(somSelf);
    AStore_TaxMethodDebug("AStore_Tax","AStore_TaxFindTaxablePrice");

    /* 
     * if it is food or clothes then return zero, 
     * otherwise return item_price 
     */
    
    if (ItemType == AStore_other) 
    {
	printf("Tax_find_taxable_price = %.2f\n",ItemPrice);
	return (ItemPrice);
    }
    else 
    {
	printf("Tax_FindTaxablePrice = %.2f\n",0.0);
	return 0.0;
    }
}

SOM_Scope void SOMLINK AStore_TaxsomDefaultInit(AStore_Tax somSelf, 
                                                somInitCtrl* ctrl)
{
    TaxState *ostate;
    AStore_TaxData *somThis; /* set in BeginInitializer */
    somInitCtrl globalCtrl;
    somBooleanVector myMask;

    CORBA_Environment ev;

    AStore_TaxMethodDebug("AStore_Tax","somDefaultInit");
    AStore_Tax_BeginInitializer_somDefaultInit;

    AStore_Tax_Init_SOMObject_somDefaultInit(somSelf, ctrl);

    /* set the tax rate, this is hard wired for simplicity */

    ostate           = SOMMalloc (sizeof(TaxState));
    somThis->ostate  = ostate;
    ostate->rate     = TAX_RATE;

    printf("Tax object initialized and ready\n");
}


SOM_Scope void SOMLINK AStore_TaxsomDestruct(AStore_Tax somSelf, 
                                             octet doFree, somDestructCtrl* ctrl)
{
    AStore_TaxData *somThis; /* set in BeginDestructor */
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    AStore_TaxMethodDebug("AStore_Tax","AStore_TaxsomDestruct");
    AStore_Tax_BeginDestructor;
    AStore_Tax_EndDestructor;
}

#undef FN
#define FN "S_AStore_Store_Login()"

SOM_Scope AStore_StoreAccess  SOMLINK AStore_StoreLogin(AStore_Store somSelf, 
                                                         Environment *ev, 
                                                        POS_POSId Id)
{
    AStore_StoreAccess store_access;
    CORBA_long         count = 0;
    CORBA_long         found = 0;
    StoreState         *ostate;

    AStore_StoreData *somThis = AStore_StoreGetData(somSelf);
    AStore_StoreMethodDebug("AStore_Store","AStore_StoreLogin");

    /* 
     * check POSList to see if store_Id exists
     * if it doesn't, add it to poslist, create a StoreAcess object
     * and return
     *
     * if store_Id is already in the list, zero out totals
     * and return existing StoreAccess object
     * 
     * As currently implemented, the POSList has room for 50 POS entries
     * If the table is full, additional POSs trying to log in will
     * receive a NULL StoreAccess object
     */

    ostate = (StoreState *) somThis->ostate;

    if (ostate->_poslist._length == MAX_POSLIST_ENTRIES)
	{
	    printf("StoreAccess _poslist overflow\n");
	    return NULL;
	}
    else
	while ((count < ostate->_poslist._length) && (!found))
	{
	    if (ostate->_poslist._buffer[count].Id == Id) found = 1;
	    count++;
	}

    if (!found)               /* 
                               * if the POSid is not already in the poslist -
                               *  add it creating StoreAccess object in the
                               * process
		               */
   
   {
        AStore_POSInfo   *new_pos;  /* temporary pointer for
                                     * textual conciseness
                                     */
	store_access = AStore_StoreAccessNew_storeInit(ev,
					ostate->_taxReference,
				        ostate->_depotReference,
					ostate->_storeMarkup,
				        ostate->_store_id);

	/* initialize the postlist entry */
        new_pos = &(ostate->_poslist._buffer[ostate->_poslist._length]);
        new_pos->StoreAccessReference = store_access;
        new_pos->Id                    = Id;
        new_pos->TotalSales            = 0;
        new_pos->TotalTaxes            = 0;


	/* increment the length field of the POSList sequence */

        ostate->_poslist._length++;

	printf(FN ": added POSid to the POSList sequence: %d\n", new_pos->Id);

	return store_access;
    }
    else
    {
        /*
         * reset POS totals
         */
        ostate->_poslist._buffer[count-1].TotalSales = 0.0;
        ostate->_poslist._buffer[count-1].TotalTaxes = 0.0;


        printf(FN " returning existing StoreAccess object for POSid: %d\n",
                   ostate->_poslist._buffer[count-1].Id);

	return ostate->_poslist._buffer[count-1].StoreAccessReference;
    }
}

SOM_Scope void  SOMLINK AStore_StoreGetPOSTotals(AStore_Store somSelf, 
                                                  Environment *ev, 
                                                 AStore_POSList* POSData)
{
    StoreState *ostate;
    AStore_StoreData *somThis = AStore_StoreGetData(somSelf);
    AStore_StoreMethodDebug("AStore_Store","AStore_StoreGetPOSTotals");

    ostate = (StoreState *) somThis->ostate;
    *POSData = ostate->_poslist;
}

#undef FN
#define FN "S_AStore_Store_UpdateStoreTotals()"

SOM_Scope void  SOMLINK AStore_StoreUpdateStoreTotals(AStore_Store somSelf, 
                                                       Environment *ev, 
                                                      POS_POSId Id, 
                                                      float Price, 
                                                      float Taxes)
{
    StoreState *ostate;
    CORBA_long count = 0;
    CORBA_long found = 0;

    AStore_StoreData *somThis = AStore_StoreGetData(somSelf);
    AStore_StoreMethodDebug("AStore_Store","AStore_StoreUpdateStoreTotals");

    ostate = (StoreState *) somThis->ostate;
    ostate->_totals.StoreTotal += Price;
    ostate->_totals.StoreTaxTotal += Taxes;
    somThis->Totals = ostate->_totals;  /*  Since the Totals attribute of the
                                         *  interface is part of the object 
                                         *  state of the object, keep the
                                         *  state current, so that the i
                                         *  SOM generated __get_Totals method
                                         *  returns the current value.
                                         */

    while ((count < ostate->_poslist._length) && (!found))
    {
	if (ostate->_poslist._buffer[count].Id == Id) found = 1;
	count++;
    }

    if (!found)
    {
	printf(FN ": there is a serious problem!\n");
	return;
    }

    ostate->_poslist._buffer[count-1].TotalSales += Price;
    ostate->_poslist._buffer[count-1].TotalTaxes += Taxes;
    
    return;
}

SOM_Scope void SOMLINK AStore_StoresomDefaultInit(AStore_Store somSelf, 
                                                  somInitCtrl* ctrl)
{
    StoreState       *ostate;
    AStore_StoreData *somThis; /* set in BeginInitializer */
    somInitCtrl globalCtrl;
    somBooleanVector myMask;

    SOMDObject sdo;
    PseudoNameService pnsRef;
    CORBA_Environment ev;

    AStore_StoreMethodDebug("AStore_Store","somDefaultInit");
    AStore_Store_BeginInitializer_somDefaultInit;

    AStore_Store_Init_SOMDServer_somDefaultInit(somSelf, ctrl);

    /** initialize the CORBA_Environment structure **/

    SOM_InitEnvironment(&ev);

    /** associate the instance data poslist array with poslist sequence **/
    /** and initialize sequence                                         **/
     
    ostate = SOMMalloc (sizeof(StoreState));
    somThis->ostate  = ostate;
    ostate->_poslist._buffer = ostate->_posarray;
    ostate->_poslist._maximum = MAX_POSLIST_ENTRIES;
    ostate->_poslist._length = 0;

    /* get an object reference to the PseudoNameService */

    pnsRef = file_to_ref(&ev, PNAME_REF);
    if (ev._major != CORBA_NO_EXCEPTION) handle_error(&ev);

    /* get depot reference from a well known place - the PNS */
    /* all names are hardcoded for simplicity */

    ostate->_depotReference = PseudoNameService_ResolveName(pnsRef, &ev,
                                              DEPOT_REF);
    if (ev._major != CORBA_NO_EXCEPTION) handle_error(&ev);
    
    /* create the Tax object locally */

    ostate->_taxReference = AStore_TaxNew();
   
    /* build an object reference for the tax object */

    SOMD_ServerObject = somSelf;
    sdo = SOMDServer_somdRefFromSOMObj(somSelf, &ev, ostate->_taxReference);
    if(ev._major != CORBA_NO_EXCEPTION) handle_error(&ev);

    /* register the Tax object with the PseudoNameServer */
   
    PseudoNameService_BindName(pnsRef, &ev, "tax", sdo);
    if(ev._major != CORBA_NO_EXCEPTION) handle_error(&ev);

    /* release the Tax object reference */

    CORBA_Object_release(sdo,&ev);
    if(ev._major != CORBA_NO_EXCEPTION) handle_error(&ev);

    /* register server with the PseudoNameService */

    register_server(&ev,somSelf);
    if (ev._major != CORBA_NO_EXCEPTION) handle_error(&ev);

    /** release the PNS object reference **/
    CORBA_Object_release(pnsRef, &ev);
    if(ev._major != CORBA_NO_EXCEPTION) handle_error(&ev);

    /**  initialize store_total = store_tax_total = 0  **/

    somThis->Totals.StoreTotal = 0;
    somThis->Totals.StoreTaxTotal = 0;

    /*  get storeid and markup instance data - hardwired for simplicity  */

    somThis->StoreId = STOREID;
    
    ostate->_store_id = somThis->StoreId;
    ostate->_storeMarkup = MARKUP;
    ostate->_totals = somThis->Totals;
    /* clean up */

    SOM_UninitEnvironment(&ev);
    printf("Store server is initialized and ready\n");
}

SOM_Scope void SOMLINK AStore_StoresomDestruct(AStore_Store somSelf, 
                                               octet doFree, 
                                               somDestructCtrl* ctrl)
{
    AStore_StoreData *somThis; /* set in BeginDestructor */
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    AStore_StoreMethodDebug("AStore_Store","AStore_StoresomDestruct");
    AStore_Store_BeginDestructor;
    AStore_Store_EndDestructor;
}

#undef FN
#define FN "S_AStore_StoreAccess_FindPrice()"

SOM_Scope void  SOMLINK AStore_StoreAccessFindPrice(AStore_StoreAccess somSelf, 
                                                     Environment *ev, 
                                                    POS_Barcode Item, 
                                                    long Quantity, 
                                                    float* ItemPrice, 
                                                    float* ItemTaxPrice, 
                                                    AStore_ItemInfo* IInfo)
{
    ItemInfo iteminfo;
    StoreAccessState  *ostate;

    AStore_StoreAccessData *somThis = AStore_StoreAccessGetData(somSelf);
    AStore_StoreAccessMethodDebug("AStore_StoreAccess",
				  "AStore_StoreAccessFindPrice");

    ostate = somThis->ostate;
    /*  get the item_info structure from the depot  */

    CentralOffice_Depot_FindItemInfo(ostate->_depot_reference, ev, 
				     ostate->_store_id,
				     Item, Quantity,
				      &iteminfo);

    /**  check for and handle exception  **/

    if (ev->_major != NO_EXCEPTION)
    {
	handle_error(ev);
	return;
    }

    /*  calculate the price based on cost + store specific markup 
     * percentage  
     */

    *ItemPrice = iteminfo.Itemcost + (iteminfo.Itemcost * ostate->markup);
    /*  call the tax server to obtain taxable amount of price  */

    *ItemTaxPrice =  AStore_Tax_FindTaxablePrice(ostate->_tax_reference, ev,
						 *ItemPrice, 
						  iteminfo.Itemtype);

    /*  free the memory returned with iteminfo  */

    *IInfo = iteminfo;

    CORBA_free(&iteminfo);

    printf(FN " : item_info->description = %s\n",  IInfo->Name);

    printf(FN " : price for item %s = %.2f taxable portion %.2f\n",
	   Item, *ItemPrice, *ItemTaxPrice);

    return;
}

/*
 * constructor for creating StoreAccess instances with
 * initialization parameters 
 */

SOM_Scope void SOMLINK AStore_StoreAccessstoreInit(AStore_StoreAccess somSelf, 
                                                    Environment *ev, 
                                                   somInitCtrl* ctrl, 
                                                   SOMObject taxref, 
                                                   SOMObject depotref, 
                                                   float markup, 
                                                   long storeid)
{
    StoreAccessState  *ostate;
    AStore_StoreAccessData *somThis; /* set in BeginInitializer */
    somInitCtrl globalCtrl;
    somBooleanVector myMask;

    AStore_StoreAccessMethodDebug("AStore_StoreAccess","storeInit");
    AStore_StoreAccess_BeginInitializer_storeInit;

    ostate = SOMMalloc (sizeof (StoreAccessState));
    somThis->ostate = ostate;
    ostate->_tax_reference = taxref;
    ostate->_depot_reference = depotref;
    ostate->markup = markup;
    ostate->_store_id = storeid;

    AStore_StoreAccess_Init_SOMObject_somDefaultInit(somSelf, ctrl);
}


SOM_Scope void SOMLINK AStore_StoreAccesssomDefaultInit(AStore_StoreAccess somSelf, 
                                                        somInitCtrl* ctrl)
{
    AStore_StoreAccessData *somThis; /* set in BeginInitializer */
    somInitCtrl globalCtrl;
    somBooleanVector myMask;

    AStore_StoreAccessMethodDebug("AStore_StoreAccess","somDefaultInit");
    AStore_StoreAccess_BeginInitializer_somDefaultInit;
    AStore_StoreAccess_Init_SOMObject_somDefaultInit(somSelf, ctrl);
}


SOM_Scope void SOMLINK AStore_StoreAccesssomDestruct(AStore_StoreAccess somSelf, 
                                                     octet doFree, 
                                                     somDestructCtrl* ctrl)
{
    AStore_StoreAccessData *somThis; /* set in BeginDestructor */
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;

    AStore_StoreAccessMethodDebug("AStore_StoreAccess","AStore_StoreAccesssomDestruct");
    AStore_StoreAccess_BeginDestructor;
    AStore_StoreAccess_EndDestructor;
}




















